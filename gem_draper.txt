Draper adds an object-oriented layer of presentation logic to your Rails application.
Draper加入邏輯呈現的物件導向層到rails app。

Without Draper, this functionality might have been tangled up in procedural helpers or adding bulk to your models. With Draper decorators, you can wrap your models with presentation-related logic to organise - and test - this layer of your app much more effectively.

沒有了drapper，這功能可能會在程序helpers亂成一團或者需要用新增批次方式到models。有了它，可以將models用以呈現關聯邏輯組織起來，也能做測試，讓app更有效率。

Imagine your application has an Article model. With Draper, you'd create a corresponding ArticleDecorator. The decorator wraps the model, and deals only with presentational concerns. In the controller, you decorate the article before handing it off to the view:

# app/controllers/articles_controller.rb
def show
  @article = Article.find(params[:id]).decorate
end

想像你的app有著一個Article model，用上draper，你能生成相對應的ArticleDecorator。這decorator包著model，單單處理呈現部分。在controller能在動手前處理好view。

In the view, you can use the decorator in exactly the same way as you would have used the model. But whenever you start needing logic in the view or start thinking about a helper method, you can implement a method on the decorator instead.

來到view，如你使用model一樣的方式來操作decorator，不論view何時需要邏輯或是考慮著helper method，都可用decorator來實作。

Let's look at how you could convert an existing Rails helper to a decorator method. You have this existing helper:

以下是將現有的rails helper轉換至decorator medhotd:

# app/helpers/articles_helper.rb
def publication_status(article)
  if article.published?
    "Published at #{article.published_at.strftime('%A, %B %e')}"
  else
    "Unpublished"
  end
end


But it makes you a little uncomfortable. publication_status lives in a nebulous namespace spread across all controllers and view. Down the road, you might want to display the publication status of a Book. And, of course, your design calls for a slightly different formatting to the date for a Book.

Now your helper method can either switch based on the input class type (poor Ruby style), or you break it out into two methods, book_publication_status and article_publication_status. And keep adding methods for each publication type...to the global helper namespace. And you'll have to remember all the names. Ick.

到此會有點不適應，發佈狀態存在於模糊的namespace，散佈在所有controller與view。此後，你會想讓發佈狀態像書般的顯示出來，你設計的呼叫會稍稍地和書讓的日期格式有些不同。

現在你的helper method可以切換輸入種類類別，也可以在兩個methods使用，book_publication_status and article_publication_status。還能接著新增mehotds到每一項發佈type到全域的helper namespace。


Ruby thrives when we use Object-Oriented style. If you didn't know Rails' helpers existed, you'd probably imagine that your view template could feature something like this:

<%= @article.publication_status %>

Ruby因我們使用物件導向而茁壯，若不清楚Rails helpers的存在，可能會認為view template的特性如程式碼：
<%= @article.publication_status %>



Without a decorator, you'd have to implement the publication_status method in the Article model. That method is presentation-centric, and thus does not belong in a model.

Instead, you implement a decorator:
沒了decorator就得再Artical model裡頭實作publication_status method。這method是針對view因而不屬於model。


# app/decorators/article_decorator.rb
class ArticleDecorator < Draper::Decorator
  delegate_all

  def publication_status
    if published?
      "Published at #{published_at}"
    else
      "Unpublished"
    end
  end

  def published_at
    object.published_at.strftime("%A, %B %e")
  end
end


Within the publication_status method we use the published? method. Where does that come from? It's a method of the source Article, whose methods have been made available on the decorator by the delegate_all call above.

有了publication_status method，我們使用published?這個方法。這個Article的method可藉著delegate_all呼叫decorator。


You might have heard this sort of decorator called a "presenter", an "exhibit", a "view model", or even just a "view" (in that nomenclature, what Rails calls "views" are actually "templates"). Whatever you call it, it's a great way to replace procedural helpers like the one above with "real" object-oriented programming.

可能有聽過些關於decorator被稱為呈現者、顯示、一個view model，甚至是"view"，不論你怎麼稱呼他，就是個取代程序heplers的好方法，好比真正的物件導向的程式設計方式。


Decorators are the ideal place to:

    format complex data for user display
    define commonly-used representations of an object, like a name method that combines first_name and last_name attributes
    mark up attributes with a little semantic HTML, like turning a url field into a hyperlink

Decorators的理想使用情境：
用戶端呈現複雜資訊。
定義共用的物件表示方式，像是name method合併了姓名兩項屬性。
用語意html來標記屬性，如將a link轉換為超連結。
