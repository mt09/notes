Draper adds an object-oriented layer of presentation logic to your Rails application.
Draper加入邏輯呈現的物件導向層到rails app。

Without Draper, this functionality might have been tangled up in procedural helpers or adding bulk to your models. With Draper decorators, you can wrap your models with presentation-related logic to organise - and test - this layer of your app much more effectively.

沒有了drapper，這功能可能會在程序helpers亂成一團或者需要用新增批次方式到models。有了它，可以將models用以呈現關聯邏輯組織起來，也能做測試，讓app更有效率。

Imagine your application has an Article model. With Draper, you'd create a corresponding ArticleDecorator. The decorator wraps the model, and deals only with presentational concerns. In the controller, you decorate the article before handing it off to the view:

# app/controllers/articles_controller.rb
def show
  @article = Article.find(params[:id]).decorate
end

想像你的app有著一個Article model，用上draper，你能生成相對應的ArticleDecorator。這decorator包著model，單單處理呈現部分。在controller能在動手前處理好view。

In the view, you can use the decorator in exactly the same way as you would have used the model. But whenever you start needing logic in the view or start thinking about a helper method, you can implement a method on the decorator instead.

來到view，如你使用model一樣的方式來操作decorator，不論view何時需要邏輯或是考慮著helper method，都可用decorator來實作。

Let's look at how you could convert an existing Rails helper to a decorator method. You have this existing helper:

以下是將現有的rails helper轉換至decorator medhotd:

# app/helpers/articles_helper.rb
def publication_status(article)
  if article.published?
    "Published at #{article.published_at.strftime('%A, %B %e')}"
  else
    "Unpublished"
  end
end


But it makes you a little uncomfortable. publication_status lives in a nebulous namespace spread across all controllers and view. Down the road, you might want to display the publication status of a Book. And, of course, your design calls for a slightly different formatting to the date for a Book.

Now your helper method can either switch based on the input class type (poor Ruby style), or you break it out into two methods, book_publication_status and article_publication_status. And keep adding methods for each publication type...to the global helper namespace. And you'll have to remember all the names. Ick.

到此會有點不適應，發佈狀態存在於模糊的namespace，散步在所有controller與view。此後，你會想讓發佈狀態像書般的顯示出來，你設計的呼叫會稍稍地和書讓的日期格式有些不同。


Ruby thrives when we use Object-Oriented style. If you didn't know Rails' helpers existed, you'd probably imagine that your view template could feature something like this:

<%= @article.publication_status %>

Ruby因我們使用物件導向而茁壯，若不清楚Rails helpers的存在，可能會認為view template的特性如程式碼：
<%= @article.publication_status %>



Without a decorator, you'd have to implement the publication_status method in the Article model. That method is presentation-centric, and thus does not belong in a model.

Instead, you implement a decorator:

# app/decorators/article_decorator.rb
class ArticleDecorator < Draper::Decorator
  delegate_all

  def publication_status
    if published?
      "Published at #{published_at}"
    else
      "Unpublished"
    end
  end

  def published_at
    object.published_at.strftime("%A, %B %e")
  end
end

Within the publication_status method we use the published? method. Where does that come from? It's a method of the source Article, whose methods have been made available on the decorator by the delegate_all call above.

You might have heard this sort of decorator called a "presenter", an "exhibit", a "view model", or even just a "view" (in that nomenclature, what Rails calls "views" are actually "templates"). Whatever you call it, it's a great way to replace procedural helpers like the one above with "real" object-oriented programming.

Decorators are the ideal place to:

    format complex data for user display
    define commonly-used representations of an object, like a name method that combines first_name and last_name attributes
    mark up attributes with a little semantic HTML, like turning a url field into a hyperlink

